---
title: "scvi-tools CITE-seq tutorial in R, using serialized tutorial components"
author: "Follows scvi-tools doc, Gayoso, Steier et al."
date: "`r format(Sys.time(), '%B %d, %Y')`"
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{scvi-tools CITE-seq tutorial in R, using serialized tutorial components}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document:
    highlight: pygments
    number_sections: yes
    theme: united
    toc: yes
---

# Overview

As of Jan 27 2023, the [scvi-tools](https://scvi-tools.org/) is
an element of the [scverse](https://scverse.org/) toolchest for
single-cell omics data analysis.

The scviR package is a very elementary approach to interfacing
between R, Bioconductor and scvi-tools.  

- scvi-tools components develop rapidly; we are
using [basilisk](https://bioconductor.org/packages/basilisk)
to manage R/python interoperation, and as of current
writing we work with version 0.18.0 of scvi-tools.  Specific
versions of python components are enumerated in the file R/basilisk.R.
- We have found it useful to use both R and python in our
developmental vignettes, which render nicely with Rstudio 2022.12.0 Build 353.
- A docker container based on a PyTorch-oriented image in
the [NVIDIA container registry](nvcr.io/nvidia/pytorch:22.12-py3) includes
R 4.2.2 and sufficient python 3 infrastructure to use scvi-tools 0.18.0
and scviR 0.0.1.  A Dockerfile is in scviR/inst/Docker;
`vjcitn/nvidpt_bioc:0.0.1` can be pulled from dockerhub, it reports
size 26.5GB.


# A CITE-seq example

## Retrieval of PBMC data
The following chunk will
acquire (and cache, using BiocFileCache) a preprocessed version of the 10k and 5k combined
CITE-seq experiments from the scvi-tools data repository.


```{r doinit}
library(scviR)
adref = get_citeseq_pbmcs()
adref
```

## Retrieval of fitted VAE

The totalVI variational autoencoder was fit
with these data.  A fitted version is retrieved and cached
using

```{r dogetv}
vae = get_citeseq_tutvae()
vae
```

The structure of the VAE is reported using
```{r lkmod, eval=FALSE}
vae$module
```
This is quite voluminous and is provided in an appendix.

## Trace of (negative) ELBO values

```{r lkelb}
h = vae$history
npts = nrow(h$elbo_train)
plot(seq_len(npts), as.numeric(h$elbo_train[[1]]), ylim=c(1200,1400), type="l", col="blue")
lines(seq_len(npts), as.numeric(h$elbo_validation[[1]]), type="l", col="orange")
```

## Normalized quantities

```{r getn}
NE = vae$get_normalized_expression(n_samples=25L, 
    return_mean=TRUE, 
    transform_batch=c("PBMC10k", "PBMC5k")
)
```
